---
layout: post
title: iOS并发编程手册
categories: [技术]
tags: [iOS]
fullview: false
comments: true

---

## 1.简介
---
并发就是很多事情同时发生，随着多核cpu的激增，软件开发者需要新的方法来利用这些核心。虽然操作系统（os x和ios）允许很多程序同时运行，但大部分后台程序都只占用很少的处理器时间，用户更关注的前台应用消耗主要的计算资源。如果一个应用有很多工作要做，但是只占用可用cpu核心的一小部分，那么其他的核心就浪费了。

以前，并发编程需要创建线程，但是编程多线程的代码是一项非常具有挑战性的工作。线程是底层工具，只能手动管理。最佳的线程数量取决于硬件和系统负载的状况，这两者不是一成不变的，这使得设计好的线程解决方案变得非常困难。而且线程中的同步机制给软件设计增加了太多的复杂度，却不能保证一定可以提升性能。

os x和ios与传统的基于线程的并发解决方案不同，引入了一个更加异步的方案。程序不在需要直接创建线程，而是定义特定任务然后把它交给系统去运行。通过让系统管理线程，程序获得了更大的弹性和更加简单高效的编程模型。

### 文档结构

这个文档包括以下章节

* 并发与程序设计，介绍基础的异步程序设计和异步执行任务的方法。
* operation queues，介绍使用oc对象怎么封装和执行任务。
* dispatch queues，介绍如何在c程序里面执行并发任务。
* dispatch sources，介绍如何异步的处理系统事件。
* 从线程转移到新技术，介绍如何把基于线程的现有程序用新技术实现。
<!--more-->

### 术语

**线程** 指posix thread

**进程** 指一个运行中的可执行程序，里面可能有多个线程。

**任务** 是一堆工作的抽象概念。

## 2.并发与程序设计
---

早期计算机性能由cpu的时钟频率决定。随着技术的进步，处理器越来越小，发热量等物理因素制约了处理器的最高时钟频率。于是处理器生产商要寻找新的增加处理器整体计算能力的方法。解决方案就是增加一个芯片上的处理器核心，这样就能在时钟频率、处理器大小、热工性能不变的情况下增加单个芯片每秒处理的指令数量，唯一的问题就是如何利用这些多出来的核心。

为了利用多个核心，软件需要同时做多个任务。现代的多任务操作系统（os x和ios）在一个时间点可能同时运行着上百个程序，所以把这些程序分配给不同的处理器核心是可能的。但是这些程序中大部分是守护进程或者后台程序，它们不会占用太多cpu时间。所以单独程序更高效的利用核心更重要。

传统的方法是创建多线程，但是随着核的增多，线程方案会遇到很多困难。最大的问题是线程数量不能非常好的适应核心数量，不能简单地创建和核心数量一样多的线程，然后指望程序能运行良好。你需要知道的是能有效利用的核心数量，这对于应用程序来说是很难获取到的。即使能获取到，让这些线程高效的或不干扰工作依然很难。

总是这个问题就是要有个利用动态数量的核心的解决方案。单个应用的工作也要可以根据系统状况来分配。并且这个方案要足够简单，不能给每个核心增加额外的工作。苹果的操作系统提供了解决方案。这章就要介绍这个方案的技术和如何让你的代码利用这些技术。

### 抛弃线程

虽然线程已经用了很长时间并将继续用下去，但是它不能让你弹性的运行多任务。使用线程创建弹性机制的重担直接压在开发者肩上，你必须考虑需要创建多少线程并且各级系统状态动态调整这个数量。而且你的应用要花大量时间来创建和管理线程。

os x和ios用异步设计来解决并行问题，而不依赖线程。异步程序已经在操作系统里面用了很多年，比如从磁盘读取文件。当需要读取时一个函数在幕后做一些事情然后在真正需要数据之前返回。通常这需要一个后台线程，在这个线程里面做要做的事情，结束的时候给调用者发一个通知（通常用回调函数）。以前如果没有合适的异步函数，那你就要自己写异步调用并创建线程。现在os x和ios可以让你不创建线程来完成异步任务。

一个异步开始任务的技术是grand central dispatch（gcd）。这个技术把通常写在应用程序里面的线程控制代码放到了系统底层。你需要做的就是定义任务，然后把它们放到合适的dispatch queue里面，gcd负责创建线程和把任务分配给线程。由于现在线程管理是系统的一部分，gcd提供了比传统线程更高效的显现出管理。

operation queues是和dispatch queue很类似的oc对象。你定义好任务，然后把它交给一个operation queue，它会负责安排这些任务然后执行它们。和gcd一样operation queues帮你处理所有的线程管理，让任务尽可能高效的运行。

接下来的部分提供dispatch queues，operation queues和其他相关的异步技术的信息。

### dispatch queues

dispatch queues是一个以c为基础的执行定制任务的机制，dispatch queue顺序或者并行的执行任务，但总会保持任务的先进先出（也就是说执行任务的顺序总会和加入queue的顺序一致）。顺序执行的queue同一时间只会执行一个任务，任务完成再执行下一个，并行的queue则同时开始尽可能多的任务。

dispatch queue的其他特点

* 提供了简单直接的编程接口。
* 提供了自动而全面的线程池管理，
* 提供汇编级别的速度优化
* 更高效的内存利用（因为线程栈不在应用程序的内存里）
* they do not trap to the kernel under load
* 异步的把任务分配给queue不会导致死锁
* they scale gracefully under contention
* 顺序queue能更高效的代替锁和其他同步原语

交给dispatch queue的任务要封装在函数或block里面。block是一个类似于函数指针的c语言特性，在os x 10.6和ios 4.0中被引入，一般来说block被定义在其他函数的作用域之内，这样它就能访问这个函数内的变量，block可以从它原本的作用域复制到堆上，当你把block提交到queue的时候就会发生这种复制。这些特性可以用很少的代码实现非常动态的任务。

### dispatch sources

dispatch sources是一个以c为基础的异步处理特定种类系统事件的机制。它包含系统事件的信息，当事件发生时把特定的block或者函数加入queue。你可以用dispatch queues检测下面这些系统事件。

* 计时器
* 信号处理器
* 描述符相关事件
* 进程相关事件
* mach port事件
* 自定义事件

### operation queues

operation queue是cocoa版的并行queue，通过NSOperationQueue类实现。不同于dispatch queue总是先进先出，operation queue还会基于其他因素来决定任务执行的顺序，其中最重要的因素是任务之间的依赖关系，在定义任务之前要安排依赖关系，通过依赖关系生成执行顺序图。

加入到operation queue的任务必须是NSOperation类的实例，operation对象封装了你要执行的任务和任务所需数据。因为NSOperation是个抽象基类，你一般要自定义一个子类，Foundation框架也包含了一些具体的子类来帮你创建和执行任务。

operation对象生成kvo通知，可以用来观察任务进展。虽然operation queue总是并行的执行操作，需要时你也可以通过依赖关系来保证任务顺序执行。

### 异步设计

在你考虑重新设计代码来支持并行之前，首先要考虑这么做是否有必要。并行可以保证主线程闲置来响应用户时间，提升代码响应速度。利用多核也可以提升代码的运行效率。但是并行会有常驻开销，同时增加了代码复杂度，提高了编写和debug的难度。

并行化会增加代码复杂度，所以不应该在应用开发周期的最后才考虑并行。正确地运用并行需要仔细考虑应用要做的任务和这些任务所需的数据结构。否则你会发现代码运行效率和响应速度反而下降了。所以有必要在开发初期花时间来设立一些目标并寻找解决方案。

每个应用的需求都不同，所以不可能告诉你具体怎么做，但是下面提供一些好的设计建议。

### 确定应用预期行为

添加并行性前，你要确定程序的理想行为，确定理想行为可以用来验证程序。也能预计一下加入并行性之后性能提升。

首先要做的是列出应用要做的任务和确定与这些任务有关的数据结构，可以从用户选择菜单或点击按钮的行为开始，这些行为相对独立并且有明确地起始点。然后列出其他没有用户交互的任务，比如基于计时器的任务。

列出上层任务之后，要把这些上层任务细分为一个个步骤，这时要关注数据结构的改变和这些改变对程序状态的影响。比如如果一个任务对一个数组内的数据做出相同的改变，那么就不会发生一个对象的改变影响另外一个。如果数据的改变相对独立，这就是一个可以并行化的点。

### 提取可执行任务单元

理解了应用的任务之后，你应该已经知道什么地方可以并行化了。如果改变工作的步骤影响最终结果，那么你可能要顺序执行这些步骤。如果不影响结果，就可以并行执行。这两种情况都要确定任务单元，这样就能把小块的任务封装到block或者operation里面加入合适的queue了。

一开始，不用过于担心确定的任务单元太多，虽然切换线程有开销，但是dispatch queue和operation queue比传统的线程开销要小很多。所以用queue执行小任务要比线程高效很多。当然你依然要观察具体的执行效率，并且调整任务单元，但是一开始不用担心任务单元太小。

### 确定你需要的queue

把任务分割好并且封装到block或者operation后，需要确定用哪种queue来执行这些任务单元。考察这些任务和任务执行顺序。

如果你用block来装任务，你可以把它们放到顺序或者并行的dispatch queue中。如果任务有顺序要求就放顺序queue，没有就放并行queue或者放多个不同的queue中。

如果用operation装任务，关注operation的配置过程就行了，如果要顺序执行任务，就要配置operation的依赖关系。防止被依赖的任务完成时间比较晚。

### 提升性能小提示

除了把任务分解成小单元，然后放入queue中，还有其他利用queue改善程序整体效率的方法。

* 如果内存是瓶颈那么考虑直接在寄存器和缓存内计算。直接在一个处理器核心的寄存器和缓存计算比从主存加载数据要快很多。担任你只有验证过这种方法确实有效才能这么做。

* 尽早的找出要顺序执行的任务，然后尽可能的让它们并行。如果任务因为依赖共享数据而必须顺序执行，考虑改变设计去掉这个共享数据，比如做个拷贝。

* 避免用锁。dispatch queue和operation queue提供的机制基本不用锁。可以用顺序执行的dispatch queue或者operation的依赖关系来保护共享资源。

* 只要可以就用系统框架。达到并行的最好方法是好好利用系统框架内建的并行设计。很多框架用线程或者其他技术来实现并行。要实现一个任务，首先看看有没有现有的api和你要做的一样。用api可以节省精力并且最大限度的做到并行。

### 性能的含义
operation queue、dispatch queue和dispatch source可以简单的让你同时运行更多的代码。但是这些技术并不能保证一定能提升应用的效率和反馈感受。你依然要负责让使用queue的设计既满足你对效率的要求还不能给应用的其他资源造成巨大负担。比如你可以创建10000个operation然后提交给operation queue。但是这样应用可能会分配大量内存，从而导致内存分页交互和性能下降。

再引入并行代码之前，你应该用一个指标评价一下现在的应用性能，引入并行之后再用相同的指标评价应用性能，然后比较一下，看性能是不是真的提升了。如果引入并行之后性能下降了，你可以用测试性能的工具来看看愿意。

### 其他并行技术

把你的代码分成小模块是增加并行化的最好方法，但是这种设计也许不能满足所有应用的需求。取决于你的任务是什么，也可以用其他方法来增加应用整体的并行化。这个部分列出一些可以考虑的其他技术。

### opencl和并行化

os x里面opencl是一个在显卡上执行一般计算的标准技术。如果你需要给大量的数据做一些定义良好的计算。opencl是个很好的技术。比如你可以用opencl执行每个像素的过滤技术，或者要同时几个数值做复杂运算。opencl擅长数据可以并行操作的问题。

虽然opencl可以并行的处理大量数据操作，但是并不适合非常一般的计算。把数据和计算处理好交给显卡需要付出很大努力，同样把结果拿回来也很麻烦。所以和系统有交互的计算不适合交给opencl。比如你不应该用opencl来处理从文件流或网络流读取的数据。交给opencl的工作必须是自包含的。这样它就能传送给显卡然后独立的做运算。

### 什么时候用线程

虽然operation queue和dispatch queue是执行并行任务的推荐方法，但是它们并不是万能的。你的应用可能还是需要创建自己的线程，那么尽量在只有在任务不能通过其他方法实现的时候才创建线程。

要实现必须在真实时间运行的代码，选择线程是比较好的。虽然dispatch queue会尽快让任务执行，它却不能用真实时间来约束，如果你需要后台运行的代码更可知，用线程比较好。

你必须明智的使用线程，能不用就不用。

## 3.operation queue
---
cocoa operation是一种用来封装异步任务的面向对象方法。operation既可以连同operation queue来使用，也可以单独使用。因为它基于objective c所以operation一般用于基于cocoa的ios和osx程序里面。

这一章将告诉你如何创建和使用operation。
