<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title></title>
		<description>这是一个个人网站</description>
		<link>/</link>
		<atom:link href="/" rel="self" type="application/rss+xml" />
		
			<item>
				<title>冰与天空</title>
				<description>&lt;h1&gt;句子一定由主语和动词组成&lt;/h1&gt;

&lt;p&gt;主语可以省略 
变成祈使句 (you should) work hard
否定 don&amp;#39;t work hard&lt;/p&gt;

&lt;h2&gt;主语&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;名词 &lt;strong&gt;cat&lt;/strong&gt; is running&lt;/li&gt;
&lt;li&gt;代词 &lt;strong&gt;he&lt;/strong&gt; is running&lt;/li&gt;
&lt;li&gt;动名词 表示做过的事情 &lt;strong&gt;listening to music&lt;/strong&gt; makes me happy&lt;/li&gt;
&lt;li&gt;不定式  表示想要 &lt;strong&gt;to study abroad&lt;/strong&gt; is my desire
代词来调整动名词和不定式句子的结构
&lt;strong&gt;it&lt;/strong&gt; makes me happy &lt;strong&gt;to listen to music&lt;/strong&gt; 动名词一般会改成不定式
&lt;strong&gt;it&lt;/strong&gt; is my desire &lt;strong&gt;to study abroad&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;名词性从句
&lt;strong&gt;that he doesn&amp;#39;t believe my words&lt;/strong&gt; makes me angry
&lt;strong&gt;whether he is happy&lt;/strong&gt; XXXXX
&lt;strong&gt;whether he can do this&lt;/strong&gt; XXXX
&lt;strong&gt;whether he came&lt;/strong&gt; XXXX
&lt;strong&gt;whether he likes&lt;/strong&gt; XXXX
&lt;strong&gt;what he is doing&lt;/strong&gt; XXXX
&lt;strong&gt;what he can do&lt;/strong&gt; XXXX
&lt;strong&gt;what he wrote&lt;/strong&gt; XXXX

&lt;ul&gt;
&lt;li&gt;名词性从句可以做主语&lt;/li&gt;
&lt;li&gt;名词性从句可以做及物动词的宾语
i know &lt;strong&gt;that he doesn&amp;#39;t believe my words&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;名词性从句做介词的宾语
i am worried about &lt;strong&gt;whether he can do it&lt;/strong&gt;
介词不能接陈述句 要改成动名词或者宾语从句
i am sure of &lt;strong&gt;his winning the game&lt;/strong&gt;
i am sure &lt;strong&gt;that he doesn&amp;#39;t believe my words&lt;/strong&gt;
i am sure &lt;strong&gt;that he will win the game&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;名词短句
 疑问词+不定式
 &lt;strong&gt;how to do it&lt;/strong&gt; is a problem&lt;/li&gt;
&lt;li&gt;其他
 &lt;strong&gt;it&lt;/strong&gt; is very far &lt;strong&gt;from beijing to shanghai&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;动词&lt;/h2&gt;

&lt;h3&gt;及物动词&lt;/h3&gt;

&lt;p&gt;需要宾语才能表达完整意思
i &lt;strong&gt;love&lt;/strong&gt; music
i &lt;strong&gt;killed&lt;/strong&gt; him
i was &lt;strong&gt;killing&lt;/strong&gt; him / i am &lt;strong&gt;killing&lt;/strong&gt; him
he was &lt;strong&gt;killed&lt;/strong&gt; by me
he was being &lt;strong&gt;killed&lt;/strong&gt; by me&lt;/p&gt;

&lt;h3&gt;不及物动词&lt;/h3&gt;

&lt;p&gt;自己可以表达完整意思
he &lt;strong&gt;laughed&lt;/strong&gt;
he was &lt;strong&gt;laughing&lt;/strong&gt;
可以修饰
he was laughing &lt;strong&gt;because he read a comic book&lt;/strong&gt;
he was laughing &lt;strong&gt;yesterday&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;不完全不及物动词&lt;/h3&gt;

&lt;p&gt;一样意思不完整 但是不能转化成被动句
1. be动词
  * he is a &lt;strong&gt;hero&lt;/strong&gt;   名词
  * the trouble is &lt;strong&gt;that i lack money&lt;/strong&gt;     名词性从句
  * the question is &lt;strong&gt;when to go&lt;/strong&gt;     名词短句
  * my hobby is &lt;strong&gt;collecting stamps&lt;/strong&gt;     动名词
  * my goal is &lt;strong&gt;to win the game&lt;/strong&gt;     不定式
  * i am &lt;strong&gt;beautiful&lt;/strong&gt;     形容词
  * the story is &lt;strong&gt;interesting&lt;/strong&gt;     作形容词的现在分词
  * i am &lt;strong&gt;interested&lt;/strong&gt; in the story     作形容词的过去分词
  * the book is &lt;strong&gt;of great value&lt;/strong&gt;     作形容词的介词短语
  * i am &lt;strong&gt;here&lt;/strong&gt;     地点副词
  * i am &lt;strong&gt;in danger&lt;/strong&gt;     地点副词短句&lt;/p&gt;

&lt;p&gt;&lt;em&gt;be 动词+现在分词&lt;/em&gt;
    * she is charming     作形容词的现在分词
    * she is reading     进行时
    * her job is reading book     动名词&lt;/p&gt;

&lt;p&gt;&lt;em&gt;be 动词+过去分词&lt;/em&gt;
      * she is tired     作形容词的过去分词
      * she was killed     被动语态&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;become
加名词 形容词或者作形容词的现在分词与过去分词
she became &lt;strong&gt;a good girl&lt;/strong&gt;
she became &lt;strong&gt;beautiful&lt;/strong&gt;
she became &lt;strong&gt;depressed&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;turn
加形容词，一般是颜色之类的
his face turned &lt;strong&gt;red&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;get
he got &lt;em&gt;mad&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;seem
加不定式做标语
he seems &lt;strong&gt;to know it&lt;/strong&gt;
加名词或者形容词
he seems &lt;strong&gt;angry&lt;/strong&gt;
he seems &lt;strong&gt;a good man&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;感官动词&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;look&lt;/li&gt;
&lt;li&gt;sound&lt;/li&gt;
&lt;li&gt;smell&lt;/li&gt;
&lt;li&gt;taste&lt;/li&gt;
&lt;li&gt;feel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;加形容词
i feel &lt;strong&gt;good&lt;/strong&gt;
加like 名词
i feel like &lt;strong&gt;an animal&lt;/strong&gt;
he smells like &lt;strong&gt;an dog&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;特殊&lt;/em&gt;
 i &lt;strong&gt;feel like taking&lt;/strong&gt; a walk today 想要做什么事情
 look into 调查
 look over 检查
 look at 看&lt;/p&gt;

&lt;h3&gt;完全及物动词&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;he loves music 名词作宾语&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;i hata him 代词做宾语&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;i want to see him     i hope to see him      i desire to see him 不定式做宾语&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动名词做宾语
 i considered studying abroad
 i imagined studying abroad
 i avoided doing this
 i escaped being killed in the accident
 i suggested putting off the game
 i recommended putting off the game
 i enjoy doing this
 i resent having to do so much work
 i stopped doing that
 i quit doing that
 do you mind opening the window
 i risked doing this&lt;/p&gt;

&lt;p&gt;i refused to do it 拒绝做什么
 i couldn&amp;#39;t resist having some ice cream 抗拒做什么&lt;/p&gt;

&lt;p&gt;i expect to read that book
 i anticipate reading that book 都是希望做什么&lt;/p&gt;

&lt;p&gt;stop doing     停止做什么
 stop to do     停止去做什么&lt;/p&gt;

&lt;p&gt;continue start begin like love hate 不定式和动名词是一样的
 i start building the house
 i start to build the house
 i love reading
 i love to read&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;名词性从句做宾语
 that / whether / when what how where
 i believe (that) he is a good man
 i don&amp;#39;t know where he lives&lt;/p&gt;

&lt;p&gt;whether可以替换成if
 i don&amp;#39;t know whether(if) he can join the party&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;名词短句做宾语 名词短句即疑问词+不定式
 i know how to do this&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
				<pubDate>Thu, 09 Mar 2017 00:00:00 +0800</pubDate>
				<link>/2017/03/09/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95.html</link>
				<guid isPermaLink="true">/2017/03/09/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95.html</guid>
			</item>
		
			<item>
				<title>Game Design Pattern笔记</title>
				<description>&lt;h3&gt;1. Command&lt;/h3&gt;

&lt;p&gt;包裹操作指令，在能实现出一个漂亮的统一接口来处理按键输入。&lt;/p&gt;

&lt;p&gt;最重要的是可以方便的实现Undo和Redo。&lt;/p&gt;

&lt;p&gt;在纸牌游戏里面应用了。&lt;/p&gt;

&lt;h3&gt;2. Flyweight&lt;/h3&gt;

&lt;p&gt;把共用的部分提取出来，而不是每一个元素都放一份。&lt;/p&gt;

&lt;p&gt;比如实现多种地形中的水，不用把水的属性放到每一个实例里面，把属性放在一起，然后每个水的实例指向它。&lt;/p&gt;

&lt;p&gt;比如对于三消来说，view的renderInfo就可以公用，不用每个view都存一份。&lt;/p&gt;

&lt;h3&gt;3. Observer&lt;/h3&gt;

&lt;p&gt;用来解耦，一个常见的实现方法就是Events和EventsListener。&lt;/p&gt;

&lt;p&gt;用链表来存储Observer是个好办法，可以方便的删除。比cocos2d使用的hash要聪明。&lt;/p&gt;

&lt;h3&gt;4. Prototype&lt;/h3&gt;

&lt;p&gt;一种用于创建对象的Pattern，基础的实现方式是clone，从一个已有的对象来快速创建出新的对象。比如cocos2d中的action。&lt;/p&gt;

&lt;p&gt;同时还讨论了用prototype来实现OO的语言，比如js，prototype和class的不同之处在于，class的变量是属于instance的，而函数是属于类的，当创建一个新的instance的时候，变量并不会被复制，而prototype类的语言，变量同样是可以复用的，非常方便的特性。
&amp;lt;!--more--&amp;gt;&lt;/p&gt;

&lt;h3&gt;5. Singleton&lt;/h3&gt;

&lt;p&gt;保证只有一个实例（例如文件操作类），提供全局访问。&lt;/p&gt;

&lt;p&gt;全局访问是个很容易被滥用的特性，同时它增加了耦合（因为必须include singleton的头文件），试访问控制变得很麻烦。&lt;/p&gt;

&lt;p&gt;文章中提到了一些解决方案&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;传递指针（这个有时候很麻烦，因为额外增加参数）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以使用父类，把原来singleton的指针放在父类里面。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把很多singleton的指针作为一个singleton的成员，比如把game作为singleton，其他例如log，file，audio之类的都通过game来访问。我喜欢这种。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;6. State&lt;/h3&gt;

&lt;p&gt;也就是状态机啦，比较有意思的是基于栈的状态机，可以把老的状态压入栈，然后再压人新的状态，这样当新的状态结束，可以方便的回到原来的状态。&lt;/p&gt;

&lt;p&gt;当然这种使用栈的方式也不是很令人惊奇，因为这更像一种理所当然的实现方法。做前进后退本来也是要用栈的。&lt;/p&gt;

&lt;p&gt;我一直不是很喜欢状态机，因为状态变多之后，转移函数和条件就会变得很不清晰，比如三消链状处理函数，实际上是也可以通过状态机来写的，因为本质上就是从一个阶段转化到另一个阶段，但是三消这种情况，我觉得状态机不是一种很灵活的处理方式。把复杂的逻辑粗暴的分成了状态。写起来感觉不是很舒服。&lt;/p&gt;

&lt;p&gt;另一个非常赞的主意是状态开始时候的onEnter函数，可以把关于本状态的代码都放到一起，比起把一些代码放到状态转移函数里面或者上一个状态里面要好很多。&lt;/p&gt;

&lt;h3&gt;7. Double Buffer&lt;/h3&gt;

&lt;p&gt;简单的说就是要按顺序读取一些值，但是前面的值在读取过程中有可能改变后面还没被读取的值，所以double buffer就是读取的时候读旧值，改的时候改新值。全部处理结束之后，把新值和旧值交换。&lt;/p&gt;

&lt;h3&gt;8. Game Loop &amp;amp; Update&lt;/h3&gt;

&lt;p&gt;就是常见的loop和update，各种游戏引擎都实现了得那种。&lt;/p&gt;

&lt;p&gt;很赞的是固定时间update的实现方法。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;double previous = getCurrentTime();
double lag = 0.0;
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - previous;
  previous = current;
  lag += elapsed;

  processInput();

  while (lag &amp;gt;= MS_PER_UPDATE)
  {
    update();
    lag -= MS_PER_UPDATE;
  }

  render();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;9. Bytecode&lt;/h3&gt;

&lt;p&gt;简要的介绍了基于栈的脚本语言的实现方式。&lt;/p&gt;

&lt;p&gt;用栈处理参数的方式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;0 func
1 pram1(push to stack)
2 param2(push to stack)
3 run(pop param from stack)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;10. Subclass Sandbox &amp;amp; Type Object&lt;/h3&gt;

&lt;p&gt;在基类里面提供一些操作，然后子类里面去调用。非常好的办法，比我在island里面搞的那个不成功的sandbox要好很多。&lt;/p&gt;

&lt;p&gt;type object 就是我在island里面用来定义元素种类的方法，使用描述元素的type和一个通用的生成元素的方法，而不是定义很多子类。&lt;/p&gt;

&lt;p&gt;比起使用表，还是json的表现力更强，麻烦的是需要自己写工具来表现每种元素的继承关系。&lt;/p&gt;

&lt;h3&gt;11. Component&lt;/h3&gt;

&lt;p&gt;本质上来说就是一种代码的拆分，不管是把每个sprite的功能拆分成component，还是把游戏的逻辑拆分成logic。&lt;/p&gt;

&lt;p&gt;component之间的通讯，最解耦的办法就是message。还可以通过他们的容器，这种快速而且比较直观。&lt;/p&gt;

&lt;h3&gt;12. Event Queue&lt;/h3&gt;

&lt;p&gt;主要是用于那些不必同步执行，同时花费很多时间的操作，比如读写文件，网络请求，可以把他们放到队列里面，好处是主要行为不至于暂停，同时统一组织还有方便优化的好处，因为增加操作的时候和已经在队列里面的操作进行合并。&lt;/p&gt;

&lt;p&gt;同时介绍了一个很赞的循环队列的实现。&lt;/p&gt;

&lt;p&gt;另外一方面的event也可理解成缓存事件，经典的例子就是键盘操作，因为程序一次只能处理一个操作，那么肯定要用队列把曹植存储起来。&lt;/p&gt;

&lt;h3&gt;13. Service Locator&lt;/h3&gt;

&lt;p&gt;例子是给单例增加了一层抽象，这样方便以后进行替换，实际上就是统一接口，方便更换实现，&lt;/p&gt;

&lt;p&gt;这个还是很重型的pattern，要写很多纯结构的代码。&lt;/p&gt;

&lt;h3&gt;14. Data Locality&lt;/h3&gt;

&lt;p&gt;优化技巧，对cpu的缓存优化，总体来说块状的排列数据肯定是缓存友好的。&lt;/p&gt;

&lt;p&gt;里面有个很厉害的例子。&lt;/p&gt;

&lt;p&gt;一般方案：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;for sprite in spriteArr
    spirte.renderComponent().update()
    spirte.aiComponent().update()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对缓存更友好的方案：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;for rc in renderComponentArr
    rc.update()
for ac in aiComponentArr
    ac.update()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;核心就是减少指针，使用静态数组。&lt;/p&gt;

&lt;p&gt;同时还要注意数组内的不活跃元素，它们被加载到缓存，但是不会参与运算。&lt;/p&gt;

&lt;p&gt;另外还提到那些不参与运算的值可以放到类外面，使用指针，这样也可以提高cache match的几率。&lt;/p&gt;

&lt;h3&gt;14. Dirty Flag&lt;/h3&gt;

&lt;p&gt;很常用，广泛意义上来说就是延迟更新，在需要用的时候才依据是否设置为dirty来更新，否则就一直不更新。&lt;/p&gt;

&lt;p&gt;渲染的例子中，延迟更新还带来了减少计算量的好处，apx2d的dirty是减少自身矩阵的计算，这里更进一步cache了整个sprite的变换矩阵。&lt;/p&gt;

&lt;h3&gt;15. Object Pool&lt;/h3&gt;

&lt;p&gt;避免创建和内存碎片，这里面有一些优化还是做的很极致的，比如尽量使用固定长度的数组，通过union来维护未激活的例子等方法。&lt;/p&gt;

&lt;p&gt;值得关注的一点是pool对新对象的初始化，还有垃圾回收时候因为pool内元素导致的问题。&lt;/p&gt;

&lt;h3&gt;16. Spatial Partition&lt;/h3&gt;

&lt;p&gt;空间划分，这部分我还是没有实际操作过，四叉树八叉树之类的东西只是听说过，以后有接触之后应该会有比较深得理解吧。&lt;/p&gt;
</description>
				<pubDate>Thu, 26 Nov 2015 00:00:00 +0800</pubDate>
				<link>/%E6%8A%80%E6%9C%AF/2015/11/26/3-game-design-pattern.html</link>
				<guid isPermaLink="true">/%E6%8A%80%E6%9C%AF/2015/11/26/3-game-design-pattern.html</guid>
			</item>
		
			<item>
				<title>挖掘机物语</title>
				<description>&lt;h2&gt;出生&lt;/h2&gt;

&lt;p&gt;世界的边缘即是岩壁！&lt;/p&gt;

&lt;p&gt;从古至今，各种规模的掘进探索从来没有停止过，随着探索的深入，异兽，秘宝、奇境不断被发现，对未知的渴望和利益的驱使，人类的活动范围和科技水平也在不断提升...&lt;/p&gt;

&lt;p&gt;现在，人类的掘进技术已经可以让小型团队甚至个人也能深入岩壁，没错，现在是一个全民探险的时代——&lt;/p&gt;

&lt;p&gt;大掘进时代！&lt;/p&gt;

&lt;p&gt;（斜体 四行字幕 大掘进时代探照灯 立体 重量感）&lt;/p&gt;

&lt;p&gt;不过呀......
（中等字体 省略号动画）&lt;/p&gt;

&lt;p&gt;这种大事其实和穿越到刚毕业学生身上的你没什么关系
所以我们先从熟悉日常生活开始吧&lt;/p&gt;

&lt;p&gt;首先，现在用高大上的橙色字体和你说话的是作者
这个世界中字体颜色和身份是密切相关的
作为初次见面的礼物请接收这个&lt;/p&gt;

&lt;p&gt;获得：菜单 ——就像所有游戏都有的那种，返回现实世界的捷径
获得：x翔技术学院教程 ——包含了各种各样的知识，有些似乎不应该写在里面
获得：0x152型挖掘机——最低端的型号，价值大概相当于一个月的食物吧，不过结实耐用，各种废品回收站都可以找到配件
获得：一大包配件——总会用得上的&lt;/p&gt;

&lt;p&gt;现在你所处在的位置是一个非常荒凉的据点的附近 我们第一个目标就是到达这个据点&lt;/p&gt;

&lt;hr&gt;

&lt;!--more--&gt;

&lt;h3&gt;挖掘机的构成&lt;/h3&gt;

&lt;p&gt;组成部分（可存在属性）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;发动机（移动速度、燃料消耗速度）&lt;/li&gt;
&lt;li&gt;普通燃料罐（普通燃料容量）&lt;/li&gt;
&lt;li&gt;战斗燃料罐（战斗燃料容量）&lt;/li&gt;
&lt;li&gt;履带/轮子（移动速度、机体耐久度、装甲等级）&lt;/li&gt;
&lt;li&gt;外壳 （护甲等级、机体耐久度）&lt;/li&gt;
&lt;li&gt;挖掘臂 （普通移动速度、残骸雷达精度）&lt;/li&gt;
&lt;li&gt;攻击武器槽（攻击强度、命中、速度、暴击率、暴击伤害）&lt;/li&gt;
&lt;li&gt;控制武器槽（攻击强度、命中、速度、暴击率、暴击伤害、特殊效果）&lt;/li&gt;
&lt;li&gt;货柜（容量、装甲等级、耐久度）&lt;/li&gt;
&lt;li&gt;泛用机器人（修复机体 合成矿物 拆解残骸 估值 零件制作水平）&lt;/li&gt;
&lt;li&gt;残骸雷达（残骸雷达精度）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;挖掘机属性&lt;/h3&gt;

&lt;h4&gt;常驻&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;探索移动速度&lt;/li&gt;
&lt;li&gt;普通燃料量&lt;/li&gt;
&lt;li&gt;货柜容量&lt;/li&gt;
&lt;li&gt;泛用机器人等级 （决定制作、拆解、估值的等级上限）&lt;/li&gt;
&lt;li&gt;雷达精确度（决定发现残骸的等级和数量）&lt;/li&gt;
&lt;li&gt;普通燃料消耗速度&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;战斗中&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;战斗移动速度 等于 探索移动速度的3倍（嗯 三倍速）&lt;/li&gt;
&lt;li&gt;机体耐久度&lt;/li&gt;
&lt;li&gt;武器耐久度&lt;/li&gt;
&lt;li&gt;武器命中&lt;/li&gt;
&lt;li&gt;武器攻击强度&lt;/li&gt;
&lt;li&gt;武器攻击速度&lt;/li&gt;
&lt;li&gt;暴击率&lt;/li&gt;
&lt;li&gt;暴击伤害加成&lt;/li&gt;
&lt;li&gt;装甲等级&lt;/li&gt;
&lt;li&gt;战斗燃料量&lt;/li&gt;
&lt;li&gt;战斗燃料消耗速度 （三倍）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;探索&lt;/h3&gt;

&lt;p&gt;移动方式&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;探索 设定方向和路程 会自动计算时间  遇到大型怪物、据点、矿物、任务会自动停止&lt;/li&gt;
&lt;li&gt;普通移动 在地图上点击点 自动计算时间 这种只能去地图上有的地点&lt;/li&gt;
&lt;li&gt;公共交通 快速去已经去过的据点和巨型城市的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;探索和普通移动损耗：普通燃料
公共交通损耗：货币
探索过程中会自动寻找物品（残骸 矿物 文物）并装入货柜&lt;/p&gt;

&lt;h3&gt;战斗&lt;/h3&gt;

&lt;h4&gt;敌人属性&lt;/h4&gt;

&lt;p&gt;和战斗中的挖掘机相同 对于生物型敌人 机体耐久=血量 武器耐久=能量 护甲等级=防御&lt;/p&gt;

&lt;h4&gt;战斗过程&lt;/h4&gt;

&lt;p&gt;一手靠点击挖掘机走位 点击一个位置 挖掘机就会走向那个位置 然后再点就会走向另外一个位置
另一手持手机 方便的位置有两个按钮 上面是攻击武器 下面是控制武器
战斗时观察怪物走位 然后不断点击攻击武器进行攻击 并在需要控制的时候点击控制武器发射控制技能&lt;/p&gt;

&lt;h4&gt;数值&lt;/h4&gt;

&lt;p&gt;基础伤害 = 攻击强度 * 敌方护甲
伤害 = （命中）？0：（暴击）？基础伤害 * 暴击伤害加成 ：基础伤害
收到伤害 = 敌方攻击强度 * 己方护甲&lt;/p&gt;

&lt;p&gt;战斗损耗：战斗燃料 机体耐久 武器耐久&lt;/p&gt;

&lt;h4&gt;战斗修复&lt;/h4&gt;

&lt;p&gt;需要钱和时间 两者反比
特殊装备需要矿物才能完全修复&lt;/p&gt;

&lt;h3&gt;游戏内物品&lt;/h3&gt;

&lt;p&gt;普通燃料 通过钱和矿物提取获得
战斗燃料 通过钱和战利品获得
矿物 探索过程中自动获取 可以提取普通燃料 卖钱 装备原材料 高级矿物可以由低级矿物合成
文物 不占货柜空间 可以做为任务物品 可以卖钱 可以收藏
残骸 可以拆解矿物 普通燃料 战斗燃料 钱 挖掘机零部件 零件图纸
钱 等价物
挖掘机零部件 制作或者从残骸直接拆解
零件图纸 残骸拆解中获得 如果残骸中有完整地零件 那么自动获得这个零件的图纸&lt;/p&gt;

&lt;p&gt;游戏内矿物 文物 零件拥有等级和品质
残骸和图纸拥有等级
这个等级与泛用机器人的水平相对应&lt;/p&gt;

&lt;h4&gt;零件机制&lt;/h4&gt;

&lt;p&gt;泛用机器人每次升级可以学会新的制式图纸 制式零件不会出现属性浮动
残骸中拆解中可以获取图纸 图纸中会记录该装备的最高效果 泛用机器人制作时会出现属性浮动
制作原料包括文物 钱 矿物
制作是瞬间完成的不包括制作时间&lt;/p&gt;
</description>
				<pubDate>Thu, 26 Nov 2015 00:00:00 +0800</pubDate>
				<link>/%E6%B8%B8%E6%88%8F/2015/11/26/2-%E6%8C%96%E6%8E%98%E6%9C%BA.html</link>
				<guid isPermaLink="true">/%E6%B8%B8%E6%88%8F/2015/11/26/2-%E6%8C%96%E6%8E%98%E6%9C%BA.html</guid>
			</item>
		
			<item>
				<title>iOS并发编程手册</title>
				<description>&lt;h2&gt;1.简介&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;并发就是很多事情同时发生，随着多核cpu的激增，软件开发者需要新的方法来利用这些核心。虽然操作系统（os x和ios）允许很多程序同时运行，但大部分后台程序都只占用很少的处理器时间，用户更关注的前台应用消耗主要的计算资源。如果一个应用有很多工作要做，但是只占用可用cpu核心的一小部分，那么其他的核心就浪费了。&lt;/p&gt;

&lt;p&gt;以前，并发编程需要创建线程，但是编程多线程的代码是一项非常具有挑战性的工作。线程是底层工具，只能手动管理。最佳的线程数量取决于硬件和系统负载的状况，这两者不是一成不变的，这使得设计好的线程解决方案变得非常困难。而且线程中的同步机制给软件设计增加了太多的复杂度，却不能保证一定可以提升性能。&lt;/p&gt;

&lt;p&gt;os x和ios与传统的基于线程的并发解决方案不同，引入了一个更加异步的方案。程序不在需要直接创建线程，而是定义特定任务然后把它交给系统去运行。通过让系统管理线程，程序获得了更大的弹性和更加简单高效的编程模型。&lt;/p&gt;

&lt;h3&gt;文档结构&lt;/h3&gt;

&lt;p&gt;这个文档包括以下章节&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;并发与程序设计，介绍基础的异步程序设计和异步执行任务的方法。&lt;/li&gt;
&lt;li&gt;operation queues，介绍使用oc对象怎么封装和执行任务。&lt;/li&gt;
&lt;li&gt;dispatch queues，介绍如何在c程序里面执行并发任务。&lt;/li&gt;
&lt;li&gt;dispatch sources，介绍如何异步的处理系统事件。&lt;/li&gt;
&lt;li&gt;从线程转移到新技术，介绍如何把基于线程的现有程序用新技术实现。
&amp;lt;!--more--&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;术语&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt; 指posix thread&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt; 指一个运行中的可执行程序，里面可能有多个线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;任务&lt;/strong&gt; 是一堆工作的抽象概念。&lt;/p&gt;

&lt;h2&gt;2.并发与程序设计&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;早期计算机性能由cpu的时钟频率决定。随着技术的进步，处理器越来越小，发热量等物理因素制约了处理器的最高时钟频率。于是处理器生产商要寻找新的增加处理器整体计算能力的方法。解决方案就是增加一个芯片上的处理器核心，这样就能在时钟频率、处理器大小、热工性能不变的情况下增加单个芯片每秒处理的指令数量，唯一的问题就是如何利用这些多出来的核心。&lt;/p&gt;

&lt;p&gt;为了利用多个核心，软件需要同时做多个任务。现代的多任务操作系统（os x和ios）在一个时间点可能同时运行着上百个程序，所以把这些程序分配给不同的处理器核心是可能的。但是这些程序中大部分是守护进程或者后台程序，它们不会占用太多cpu时间。所以单独程序更高效的利用核心更重要。&lt;/p&gt;

&lt;p&gt;传统的方法是创建多线程，但是随着核的增多，线程方案会遇到很多困难。最大的问题是线程数量不能非常好的适应核心数量，不能简单地创建和核心数量一样多的线程，然后指望程序能运行良好。你需要知道的是能有效利用的核心数量，这对于应用程序来说是很难获取到的。即使能获取到，让这些线程高效的或不干扰工作依然很难。&lt;/p&gt;

&lt;p&gt;总是这个问题就是要有个利用动态数量的核心的解决方案。单个应用的工作也要可以根据系统状况来分配。并且这个方案要足够简单，不能给每个核心增加额外的工作。苹果的操作系统提供了解决方案。这章就要介绍这个方案的技术和如何让你的代码利用这些技术。&lt;/p&gt;

&lt;h3&gt;抛弃线程&lt;/h3&gt;

&lt;p&gt;虽然线程已经用了很长时间并将继续用下去，但是它不能让你弹性的运行多任务。使用线程创建弹性机制的重担直接压在开发者肩上，你必须考虑需要创建多少线程并且各级系统状态动态调整这个数量。而且你的应用要花大量时间来创建和管理线程。&lt;/p&gt;

&lt;p&gt;os x和ios用异步设计来解决并行问题，而不依赖线程。异步程序已经在操作系统里面用了很多年，比如从磁盘读取文件。当需要读取时一个函数在幕后做一些事情然后在真正需要数据之前返回。通常这需要一个后台线程，在这个线程里面做要做的事情，结束的时候给调用者发一个通知（通常用回调函数）。以前如果没有合适的异步函数，那你就要自己写异步调用并创建线程。现在os x和ios可以让你不创建线程来完成异步任务。&lt;/p&gt;

&lt;p&gt;一个异步开始任务的技术是grand central dispatch（gcd）。这个技术把通常写在应用程序里面的线程控制代码放到了系统底层。你需要做的就是定义任务，然后把它们放到合适的dispatch queue里面，gcd负责创建线程和把任务分配给线程。由于现在线程管理是系统的一部分，gcd提供了比传统线程更高效的显现出管理。&lt;/p&gt;

&lt;p&gt;operation queues是和dispatch queue很类似的oc对象。你定义好任务，然后把它交给一个operation queue，它会负责安排这些任务然后执行它们。和gcd一样operation queues帮你处理所有的线程管理，让任务尽可能高效的运行。&lt;/p&gt;

&lt;p&gt;接下来的部分提供dispatch queues，operation queues和其他相关的异步技术的信息。&lt;/p&gt;

&lt;h3&gt;dispatch queues&lt;/h3&gt;

&lt;p&gt;dispatch queues是一个以c为基础的执行定制任务的机制，dispatch queue顺序或者并行的执行任务，但总会保持任务的先进先出（也就是说执行任务的顺序总会和加入queue的顺序一致）。顺序执行的queue同一时间只会执行一个任务，任务完成再执行下一个，并行的queue则同时开始尽可能多的任务。&lt;/p&gt;

&lt;p&gt;dispatch queue的其他特点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提供了简单直接的编程接口。&lt;/li&gt;
&lt;li&gt;提供了自动而全面的线程池管理，&lt;/li&gt;
&lt;li&gt;提供汇编级别的速度优化&lt;/li&gt;
&lt;li&gt;更高效的内存利用（因为线程栈不在应用程序的内存里）&lt;/li&gt;
&lt;li&gt;they do not trap to the kernel under load&lt;/li&gt;
&lt;li&gt;异步的把任务分配给queue不会导致死锁&lt;/li&gt;
&lt;li&gt;they scale gracefully under contention&lt;/li&gt;
&lt;li&gt;顺序queue能更高效的代替锁和其他同步原语&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交给dispatch queue的任务要封装在函数或block里面。block是一个类似于函数指针的c语言特性，在os x 10.6和ios 4.0中被引入，一般来说block被定义在其他函数的作用域之内，这样它就能访问这个函数内的变量，block可以从它原本的作用域复制到堆上，当你把block提交到queue的时候就会发生这种复制。这些特性可以用很少的代码实现非常动态的任务。&lt;/p&gt;

&lt;h3&gt;dispatch sources&lt;/h3&gt;

&lt;p&gt;dispatch sources是一个以c为基础的异步处理特定种类系统事件的机制。它包含系统事件的信息，当事件发生时把特定的block或者函数加入queue。你可以用dispatch queues检测下面这些系统事件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计时器&lt;/li&gt;
&lt;li&gt;信号处理器&lt;/li&gt;
&lt;li&gt;描述符相关事件&lt;/li&gt;
&lt;li&gt;进程相关事件&lt;/li&gt;
&lt;li&gt;mach port事件&lt;/li&gt;
&lt;li&gt;自定义事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;operation queues&lt;/h3&gt;

&lt;p&gt;operation queue是cocoa版的并行queue，通过NSOperationQueue类实现。不同于dispatch queue总是先进先出，operation queue还会基于其他因素来决定任务执行的顺序，其中最重要的因素是任务之间的依赖关系，在定义任务之前要安排依赖关系，通过依赖关系生成执行顺序图。&lt;/p&gt;

&lt;p&gt;加入到operation queue的任务必须是NSOperation类的实例，operation对象封装了你要执行的任务和任务所需数据。因为NSOperation是个抽象基类，你一般要自定义一个子类，Foundation框架也包含了一些具体的子类来帮你创建和执行任务。&lt;/p&gt;

&lt;p&gt;operation对象生成kvo通知，可以用来观察任务进展。虽然operation queue总是并行的执行操作，需要时你也可以通过依赖关系来保证任务顺序执行。&lt;/p&gt;

&lt;h3&gt;异步设计&lt;/h3&gt;

&lt;p&gt;在你考虑重新设计代码来支持并行之前，首先要考虑这么做是否有必要。并行可以保证主线程闲置来响应用户时间，提升代码响应速度。利用多核也可以提升代码的运行效率。但是并行会有常驻开销，同时增加了代码复杂度，提高了编写和debug的难度。&lt;/p&gt;

&lt;p&gt;并行化会增加代码复杂度，所以不应该在应用开发周期的最后才考虑并行。正确地运用并行需要仔细考虑应用要做的任务和这些任务所需的数据结构。否则你会发现代码运行效率和响应速度反而下降了。所以有必要在开发初期花时间来设立一些目标并寻找解决方案。&lt;/p&gt;

&lt;p&gt;每个应用的需求都不同，所以不可能告诉你具体怎么做，但是下面提供一些好的设计建议。&lt;/p&gt;

&lt;h3&gt;确定应用预期行为&lt;/h3&gt;

&lt;p&gt;添加并行性前，你要确定程序的理想行为，确定理想行为可以用来验证程序。也能预计一下加入并行性之后性能提升。&lt;/p&gt;

&lt;p&gt;首先要做的是列出应用要做的任务和确定与这些任务有关的数据结构，可以从用户选择菜单或点击按钮的行为开始，这些行为相对独立并且有明确地起始点。然后列出其他没有用户交互的任务，比如基于计时器的任务。&lt;/p&gt;

&lt;p&gt;列出上层任务之后，要把这些上层任务细分为一个个步骤，这时要关注数据结构的改变和这些改变对程序状态的影响。比如如果一个任务对一个数组内的数据做出相同的改变，那么就不会发生一个对象的改变影响另外一个。如果数据的改变相对独立，这就是一个可以并行化的点。&lt;/p&gt;

&lt;h3&gt;提取可执行任务单元&lt;/h3&gt;

&lt;p&gt;理解了应用的任务之后，你应该已经知道什么地方可以并行化了。如果改变工作的步骤影响最终结果，那么你可能要顺序执行这些步骤。如果不影响结果，就可以并行执行。这两种情况都要确定任务单元，这样就能把小块的任务封装到block或者operation里面加入合适的queue了。&lt;/p&gt;

&lt;p&gt;一开始，不用过于担心确定的任务单元太多，虽然切换线程有开销，但是dispatch queue和operation queue比传统的线程开销要小很多。所以用queue执行小任务要比线程高效很多。当然你依然要观察具体的执行效率，并且调整任务单元，但是一开始不用担心任务单元太小。&lt;/p&gt;

&lt;h3&gt;确定你需要的queue&lt;/h3&gt;

&lt;p&gt;把任务分割好并且封装到block或者operation后，需要确定用哪种queue来执行这些任务单元。考察这些任务和任务执行顺序。&lt;/p&gt;

&lt;p&gt;如果你用block来装任务，你可以把它们放到顺序或者并行的dispatch queue中。如果任务有顺序要求就放顺序queue，没有就放并行queue或者放多个不同的queue中。&lt;/p&gt;

&lt;p&gt;如果用operation装任务，关注operation的配置过程就行了，如果要顺序执行任务，就要配置operation的依赖关系。防止被依赖的任务完成时间比较晚。&lt;/p&gt;

&lt;h3&gt;提升性能小提示&lt;/h3&gt;

&lt;p&gt;除了把任务分解成小单元，然后放入queue中，还有其他利用queue改善程序整体效率的方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果内存是瓶颈那么考虑直接在寄存器和缓存内计算。直接在一个处理器核心的寄存器和缓存计算比从主存加载数据要快很多。担任你只有验证过这种方法确实有效才能这么做。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽早的找出要顺序执行的任务，然后尽可能的让它们并行。如果任务因为依赖共享数据而必须顺序执行，考虑改变设计去掉这个共享数据，比如做个拷贝。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免用锁。dispatch queue和operation queue提供的机制基本不用锁。可以用顺序执行的dispatch queue或者operation的依赖关系来保护共享资源。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只要可以就用系统框架。达到并行的最好方法是好好利用系统框架内建的并行设计。很多框架用线程或者其他技术来实现并行。要实现一个任务，首先看看有没有现有的api和你要做的一样。用api可以节省精力并且最大限度的做到并行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;性能的含义&lt;/h3&gt;

&lt;p&gt;operation queue、dispatch queue和dispatch source可以简单的让你同时运行更多的代码。但是这些技术并不能保证一定能提升应用的效率和反馈感受。你依然要负责让使用queue的设计既满足你对效率的要求还不能给应用的其他资源造成巨大负担。比如你可以创建10000个operation然后提交给operation queue。但是这样应用可能会分配大量内存，从而导致内存分页交互和性能下降。&lt;/p&gt;

&lt;p&gt;再引入并行代码之前，你应该用一个指标评价一下现在的应用性能，引入并行之后再用相同的指标评价应用性能，然后比较一下，看性能是不是真的提升了。如果引入并行之后性能下降了，你可以用测试性能的工具来看看愿意。&lt;/p&gt;

&lt;h3&gt;其他并行技术&lt;/h3&gt;

&lt;p&gt;把你的代码分成小模块是增加并行化的最好方法，但是这种设计也许不能满足所有应用的需求。取决于你的任务是什么，也可以用其他方法来增加应用整体的并行化。这个部分列出一些可以考虑的其他技术。&lt;/p&gt;

&lt;h3&gt;opencl和并行化&lt;/h3&gt;

&lt;p&gt;os x里面opencl是一个在显卡上执行一般计算的标准技术。如果你需要给大量的数据做一些定义良好的计算。opencl是个很好的技术。比如你可以用opencl执行每个像素的过滤技术，或者要同时几个数值做复杂运算。opencl擅长数据可以并行操作的问题。&lt;/p&gt;

&lt;p&gt;虽然opencl可以并行的处理大量数据操作，但是并不适合非常一般的计算。把数据和计算处理好交给显卡需要付出很大努力，同样把结果拿回来也很麻烦。所以和系统有交互的计算不适合交给opencl。比如你不应该用opencl来处理从文件流或网络流读取的数据。交给opencl的工作必须是自包含的。这样它就能传送给显卡然后独立的做运算。&lt;/p&gt;

&lt;h3&gt;什么时候用线程&lt;/h3&gt;

&lt;p&gt;虽然operation queue和dispatch queue是执行并行任务的推荐方法，但是它们并不是万能的。你的应用可能还是需要创建自己的线程，那么尽量在只有在任务不能通过其他方法实现的时候才创建线程。&lt;/p&gt;

&lt;p&gt;要实现必须在真实时间运行的代码，选择线程是比较好的。虽然dispatch queue会尽快让任务执行，它却不能用真实时间来约束，如果你需要后台运行的代码更可知，用线程比较好。&lt;/p&gt;

&lt;p&gt;你必须明智的使用线程，能不用就不用。&lt;/p&gt;

&lt;h2&gt;3.operation queue&lt;/h2&gt;

&lt;hr&gt;

&lt;p&gt;cocoa operation是一种用来封装异步任务的面向对象方法。operation既可以连同operation queue来使用，也可以单独使用。因为它基于objective c所以operation一般用于基于cocoa的ios和osx程序里面。&lt;/p&gt;

&lt;p&gt;这一章将告诉你如何创建和使用operation。&lt;/p&gt;
</description>
				<pubDate>Thu, 26 Nov 2015 00:00:00 +0800</pubDate>
				<link>/%E6%8A%80%E6%9C%AF/2015/11/26/1-iOS%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C.html</link>
				<guid isPermaLink="true">/%E6%8A%80%E6%9C%AF/2015/11/26/1-iOS%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C.html</guid>
			</item>
		
			<item>
				<title>一个例子</title>
				<description>&lt;p&gt;存一下格式&lt;/p&gt;
</description>
				<pubDate>Thu, 26 Nov 2015 00:00:00 +0800</pubDate>
				<link>/%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF/2015/11/26/0-%E4%BE%8B%E5%AD%90.html</link>
				<guid isPermaLink="true">/%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF/2015/11/26/0-%E4%BE%8B%E5%AD%90.html</guid>
			</item>
		
	</channel>
</rss>
